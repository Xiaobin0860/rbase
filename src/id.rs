use anyhow::Context;
use chrono::DateTime;
use sonyflake::{Builder, Sonyflake};

#[derive(Clone)]
pub struct IdGen {
    gen: Sonyflake,
}

static BASE: u64 = 50;

static DECODE: [u64; 256] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2f, 0x30, 0x31, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x00, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x00,
    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x28, 0x00, 0x29, 0x2a, 0x00,
    0x2b, 0x00, 0x2c, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

static ENCODE: [char; 50] = [
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M',
    'N', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'k', 'm', 'n', 'p', 'r', 't', 'y', 'A', 'B', 'C',
];

static START_TS: i64 = 1704038400;

impl IdGen {
    pub fn new() -> Self {
        let start_ts = DateTime::from_timestamp(START_TS, 0)
            .context("invalid start timestamp")
            .unwrap();
        let gen = Builder::new()
            .start_time(start_ts)
            .finalize()
            .context("failed to build Sonyflake")
            .unwrap();
        Self { gen }
    }

    pub fn next(&self) -> u64 {
        self.gen.next_id().unwrap()
    }

    pub fn cid2uid(cid: &str) -> u64 {
        let mut uid: u64 = 0;
        for c in cid.chars().rev() {
            uid *= BASE;
            uid += DECODE[c as usize];
        }
        uid
    }

    pub fn is_valid_cid(cid: &str) -> bool {
        let mut result = true;
        for c in cid.chars() {
            match c {
                '0'..='9' => continue,
                'a'..='k' => continue,
                'm' | 'n' | 'p' | 'r' | 't' | 'y' => continue,
                'A'..='H' => continue,
                'J'..='N' => continue,
                'Q'..='T' => continue,
                'U'..='Z' => continue,
                _ => {
                    result = false;
                    break;
                }
            }
        }
        result
    }

    pub fn uid2cid(uid: u64) -> String {
        let mut cid = String::new();
        let mut u = uid;
        while u > 0 {
            cid.push(ENCODE[(u % BASE) as usize]);
            u /= BASE;
        }
        cid
    }
}

impl Default for IdGen {
    fn default() -> Self {
        Self::new()
    }
}

#[test]
fn id_gen_should_work() {
    let gen = IdGen::default();
    let id = gen.next();
    assert!(id > 0);
    let cid = IdGen::uid2cid(id);
    let uid = IdGen::cid2uid(&cid);
    assert_eq!(id, uid);
}
